#include <cstdlib>
#include <cstdio>
#include <cstring>
#include <csignal>
#include <cstdint>
#include <iostream>

void safe_command(const char* command)
{
    const char* ALLOWED_COMMANDS[] = { 
        "id", "pwd", "whoami"
    };
    const char* BLACKLISTED_WORDS[] = {
        "/", "sh", "bash", "zsh", ";", "&&", "||", "*", "?", "(", ")", "|", "`"
    };

    for (const char* allowed_command : ALLOWED_COMMANDS) {
        if (strstr(command, allowed_command) == command) {
            for (const char* blacklisted_word : BLACKLISTED_WORDS) {
                if (strstr(command, blacklisted_word)) {
                    std::cout << "Command not allowed!" << std::endl;
                    return;
                }
            }

            execl("/bin/bash", "bash", "-c", command, (char*)NULL);
            return;
        }
    }

    std::cout << "Command not allowed!" << std::endl;
}

#pragma pack(push, 16)
class BaseCommandExecutor {
public:
    BaseCommandExecutor() : default_command_only_{ true } {}

    virtual void execute(const char* command) 
    {
        if (default_command_only_) {
            if (strstr(command, "id")) {
                safe_command("id");
            }
            else if (strstr(command, "pwd")) {
                safe_command("pwd");
            }
            else if (strstr(command, "whoami")) {
                safe_command("whoami");
            }
            else {
                std::cout << "Command not allowed!" << std::endl;
            }
        }
        else {
            std::cout << "Only default commands are allowed!" << std::endl;
        }
    }

protected:
    bool default_command_only_;
};

class CommandExecutor : public BaseCommandExecutor {
public:
    CommandExecutor() : BaseCommandExecutor() {}

    virtual void execute(const char* command) override
    {
        BaseCommandExecutor::execute(command);
    }
};

class FullCommandExecutor : public BaseCommandExecutor {
public:
    FullCommandExecutor() : BaseCommandExecutor(), full_command_pin_{ 0 } {}

    virtual void execute(const char* command) override
    {
        std::cout << "Execute full command: " << command << std::endl;
        if (default_command_only_) {
            BaseCommandExecutor::execute(command);
        }
        else if (full_command_pin_ == 0xd34db33f) {
            safe_command(command);
        }
    }

private:
    unsigned int full_command_pin_;
};
#pragma pack(pop)

void sig_handler(int signum)
{
    (void)signum;
    FullCommandExecutor full_executor{};
	exit(0);
}

void setup()
{
    alarm(60);

    std::signal(SIGALRM, sig_handler);
    
    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stderr, NULL, _IONBF, 0);
}

int main()
{
    setup();

    CommandExecutor executor{};
    char buf[64];

    std::cout << "Enter command: ";
    std::cin >> buf;

    long** executorAddress = (long**)&executor;
    ((void (*)(uintptr_t, const char*))(executorAddress[0][0]))((uintptr_t)&executor, buf);

    return 0;
}
